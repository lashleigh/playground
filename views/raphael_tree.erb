<div id="fire" style="clear:both;">
  <button onclick="addParticle()">Add 1 Particle</button>
  <button onclick="addTenParticle()">Add 10 Particles</button>
  <button onclick="walk_one()">Fast Predictive Walk</button>
  <button onclick="walk_one_with_interval()">Visible Walk</button>
  <button onclick="walk_fast()">Fast Walk</button>
</div>
<script type="text/javascript" src="js/tree.js"></script>
<script type="text/javascript" src="js/makeColor.js"></script>
<script type="text/javascript" src="js/raphael-min.js"></script>

<script>
  var PARTICLE_RADIUS = 5;
  var DIAMETER_SQUARED = 4*PARTICLE_RADIUS*PARTICLE_RADIUS;
  var RADIUS = 400;
  var CANVAS_WIDTH = RADIUS*2;
  var CANVAS_HEIGHT = RADIUS*2;
  var trunk;
  var particles = {};
  var canvas;
  var paper;
  var background;
  var TIME = Math.floor(Math.random()*1530);
  var intervalID;
  var UNIQUE_ID = 0;
  var drop_radius = 6*PARTICLE_RADIUS;
  var max_dist = 0;

  QuadTree.prototype.DivisionParams = function() {
    if(this.items && this.items.length > 4 && (this.x_max-this.x_min > 8*PARTICLE_RADIUS)) {
      this.Divide();
    }
  }

  $(function() {
    paper = Raphael(0, 50, CANVAS_WIDTH, CANVAS_HEIGHT);
    clear();
    trunk = new QuadTree(null, 0, CANVAS_WIDTH, 0, CANVAS_HEIGHT);
  });

  function walk_fast() {
    var p = new Particle();
    console.log('new', p);
    while(!p.has_neighbors(trunk)) {
      p = p.walk(PARTICLE_RADIUS, CANVAS_WIDTH);
      if(!p) {
        p = new Particle()
        console.log("out of bounds", p);
      }
    }
    addParticle(p.x, p.y);
  }
  function random_angle(p) {
    p.angle = Math.random()*2*Math.PI;
    return p;
  }
  function draw_line(p, step) { 
    step = step || 40;
    var dx = step*Math.cos(p.angle)
    var dy = step*Math.sin(p.angle);
    var x = p.x, y = p.y, 
        x2 = p.x+dx, y2 = p.y+dy; 
    paper.path("M"+x+" "+y+" L"+x2+" "+y2)
    .mouseover(function() {
      console.log(dy/dx, dx, dy);
    })
  }
  function walk_one() {
    var p = new Particle();
    while(p.has_neighbors(trunk)) { p = new Particle(); console.log("on top");}
    var c = paper.circle(p.x, p.y, PARTICLE_RADIUS)
    var stat = 'walk'; 
    while(stat === 'walk' && drop_radius < RADIUS) {
      var res = p.vector_walk(PARTICLE_RADIUS, CANVAS_WIDTH, trunk);
      p = res.p;
      stat = res.stat;
     
      switch(stat) {
        case 'neighbor': if(!!p.x && !!p.y) {if(res.dist > max_dist) {max_dist=res.dist; drop_radius = max_dist+6*PARTICLE_RADIUS; console.log(drop_radius);}; addParticle(p.x, p.y);}; break;
        case 'destroy' : p = new Particle(); stat = 'walk'; break;
        default: break;
      }
    }
  }
  function walk_one_with_interval() {
    var p = new Particle();
    while(p.has_neighbors(trunk)) { p = new Particle(); console.log("on top");}
    var c = paper.circle(p.x, p.y, PARTICLE_RADIUS)
    var stat = 'walk'; 
    setInterval(function() {
      if(stat === 'walk' && drop_radius < RADIUS) {
        var res = p.predictive_walk(PARTICLE_RADIUS, CANVAS_WIDTH, trunk);
        p = res.p;
        stat = res.stat;
        //var anim = Raphael.animation({cx: p.x, cy: p.y}, 2e3);
        //c.animate(anim); //
        c.attr({'cx':p.x, 'cy':p.y});
       
        switch(stat) {
          case 'neighbor': if(!!p.x && !!p.y) {if(res.dist > max_dist) {max_dist=res.dist; drop_radius = max_dist+6*PARTICLE_RADIUS; console.log(drop_radius);}; addParticle(p.x, p.y);}; break;
          case 'destroy' : p = new Particle(); stat = 'walk'; break;
          default: break;
        }
      }
    }, 1000/1500);
  }
  function clear() {
    paper.clear()
    background = paper.rect(0,0,CANVAS_WIDTH, CANVAS_HEIGHT)
    background.attr({'fill':'#fff'}).mouseup(function(e) {
      addParticle(e.offsetX, e.offsetY)
    });
    paper.circle(400, 400, drop_radius)
    paper.circle(400, 400, drop_radius+8*PARTICLE_RADIUS)
  }
  function addParticle(x, y) {
    var p = new Particle(x, y)
    UNIQUE_ID++;
    p.id = UNIQUE_ID;
    particles[p.id] = p;
    trunk.Insert(p);
    draw_tree();
  }
  function addTenParticle() {
    for(var i=0; i < 10; i++) {
      addParticle();
    }
  }
  function draw_ball(ball, branch) {
    var circle = paper.circle(ball.x, ball.y, PARTICLE_RADIUS);
    var neighbors = trunk.LeafLevelNeighbors(ball);
    circle.attr({'fill': branch.color})
    .data({'id':ball.id, 'branch':neighbors})
    .mouseover(function() {
      for(var i=0; i < neighbors.length; i++) {
        neighbors[i].rect.attr({'fill':'#A9AAAC'});
      }
    }).mouseout(function() {
      for(var i=0; i < neighbors.length; i++) {
        neighbors[i].rect.attr({'fill':''});
      }
    }); 
  }
  function draw_tree() {
    clear();
    find_branches(trunk);
  }
  function find_branches(b) {
    if(!b.IsLeaf()) {
      delete b['rect'];
      find_branches(b.nw);
      find_branches(b.sw);
      find_branches(b.ne);
      find_branches(b.se);
    } else {
      draw_branch(b);
      for(var i=0; i < b.items.length; i++) {
        draw_ball(b.items[i], b);
      }
    } 
  }
  function draw_branch(b) {
    if(!b.color) {
      b.color = makeColor();
    }
    b.rect = paper.rect(b.x_min, b.y_min, (b.x_max-b.x_min), (b.y_max-b.y_min)); 
  }

</script>
