<div id="functions" style="clear:both;">
<button onclick="startSimulation()">Start or restart</button>
<button onclick="play()">Play</button></br>
<button onclick="pause()">Pause</button></br>
<button onclick="save()">Save</button></br>
</div>

<script>
var simulations = [];  
var sim;
var sim_stats = '<div class="result"></div>'+'<div class="time"></div>';

function init(size, pixels_per) {
  var that = this;

  var TIME = 765;
  this.COLOR = makeColor(TIME);
  this.CANVAS_SIZE = size || 1800;
  this.STEP = pixels_per || 2;

  this.MAX = Math.floor(that.CANVAS_SIZE/this.STEP);
  this.HALF_MAX = Math.floor(this.MAX/2);
  this.idle = true;
  this.grid = [];
  this.edge = 25; //Math.floor(HALF_MAX/2);

  this.start_time;
  this.finish_time;
  this.intervalID;
  this.canvas;
  this.context;
  this.execute = randomMatch;
  this.clear_canvas = clear;

  // canvas element and 2D context

  that.canvas = document.createElement('canvas');
  that.canvas.width = that.CANVAS_SIZE;
  that.canvas.height = that.CANVAS_SIZE;
  $(that.canvas).addClass("mycanvas");
  //document.body.appendChild(that.canvas);
  $("#functions").after(that.canvas);
  $(that.canvas).before(sim_stats);
  that.context = that.canvas.getContext('2d');

  that.context.fillStyle="rgb(255,255,255)";
  that.context.fillRect(0,0, that.CANVAS_SIZE, that.CANVAS_SIZE);

  function randomMatch(iters) {
    that.idle = false;
    $('.result').first().text("computing");
    worker.postMessage({'cmd': 'grid', 'grid':that.grid, 'dim':that.MAX, 'edge':that.edge, 'num':iters});
  }

  var worker = new Worker('js/worker.js');

  worker.addEventListener('message', function(e) {
    var res = e.data;
    that.edge = res.edge;
    //console.log(that.edge, Math.sqrt(res.max_dist));
    for(var i = 0; i < res.coords.length; i++) {
      if(i%25===0) { TIME += 1; that.COLOR = makeColor(TIME);}
      var x = res.coords[i].x;
      var y = res.coords[i].y;
      that.grid[x][y] += 1;
      draw_point(that, x, y); 
    }
    $('.result').first().text(res.iter+" and coords length: "+res.coords.length);
    if((res.iter != 0) && (that.edge < that.HALF_MAX)) {
      that.idle = true;
    } else {
      that.finish_time = new Date();
      $(".time").first().text("Finished in: "+(that.finish_time-that.start_time)/1000.0+" sec");
    }
  }, false);
} 
 
function draw_point(sim,x,y,exception) {
  if(sim.grid[x][y]==1 || exception) {
  var c = sim.context;
  c.fillStyle = sim.COLOR;
  c.beginPath();
  c.rect(x*sim.STEP, y*sim.STEP, sim.STEP, sim.STEP)
  c.closePath();
  c.fill();
  }
}
function clear_point(x,y) {
  var c = sim.context;
  c.fillStyle = '#fff'; 
  c.beginPath();
  c.rect(x*sim.STEP, y*sim.STEP, sim.STEP, sim.STEP)
  c.closePath();
  c.fill();
}

// Do Awesome Things With Colors!
function makeColor(index) {
  function color(i) {
    // Wrap around using modulus 
    i = Math.floor(i) % 1530;

    // Calculate the value
    var v;
    if(i < 255)       v = i;
    else if(i < 765)  v = 255;
    else if(i < 1020) v = 255 - (i - 765);
    else              v = 0;

    // Make it a zero-padded value
    v = v.toString(16);
    if(v.length == 1) return "0" + v;
    else              return v;
  }
  function red(i)   { return color(i + 510); }
  function green(i) { return color(i);        }
  function blue(i)  { return color(i + 1020);  }

  return "#" + red(index) + green(index) + blue(index);
}
function startSimulation(iters, SIZE, pixels_per) {
  sim = new init(SIZE || 600, pixels_per || 3)
  sim.start_time = new Date();
  clear(sim);
  play(iters, sim);
}
function pause(sim) {
  sim.idle = false;
  clearInterval(sim.intervalID)
}
function play(iters, sim) {
  sim.idle = true;
  sim.intervalID = setInterval(function() {
    if(sim.idle) {
      sim.execute(iters || 75);
    }
  }, 1000/30);
}
function clear(sim) {
  pause(sim);
  sim.edge = 25;
  reset_grid(sim);
  create_nuclei(sim);
  sim.context.fillStyle="rgb(255,255,255)";
  sim.context.fillRect(0,0, sim.CANVAS_SIZE, sim.CANVAS_SIZE);
}
function save() {
  window.open( sim.canvas.toDataURL('image/png'), 'mywindow' );
}

function reset_grid(sim) {
  for(var i=0; i < sim.MAX; i++) {
    sim.grid[i] = [];
    for(var j=0; j < sim.MAX; j++) {
      sim.grid[i][j] = 0;
    }  
  }
}
function create_nuclei(sim) {
  for(var i=sim.HALF_MAX-2; i<sim.HALF_MAX+2; i++) {
    for(var j=sim.HALF_MAX-2; j<sim.HALF_MAX+2; j++) {
      sim.grid[i][j] = 1;
      draw_point(sim, i, j);
    }
  }
}
function random_from_polar(radius) {
  var angle = Math.random()*2*Math.PI;
  var x = Math.floor(radius*Math.cos(angle))+MAX/2
  var y = Math.floor(radius*Math.sin(angle))+MAX/2
  return {'x':x, 'y':y};
}
function draw_circle(radius) {
  for(var i=0; i<radius*8; i++) {c = random_from_polar(radius, MAX); draw_point(sim, c.x, c.y, true)}
}
function clear_circle(radius) {
  for(var i=0; i<radius*8; i++) {c = random_from_polar(radius, MAX); clear_point(c.x, c.y)}
}
</script>
